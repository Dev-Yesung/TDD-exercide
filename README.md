# 📝'테스트 주도 개발 시작하기(최범균 저)'

## 👀 책을 공부한 진도를 체크하는 README입니다.

### 🧐 현재 진도

77p까지 완료 (23/1/26)
ch03 완료 (23/1/28)

- [x] ch02 - 'TDD시작' : 암호 강도 검사 기능
  정리 : 암호 강도 검사 기능을 TDD로 구현하였는데,
  그 과정은 '테스트 > 코딩 > 리팩토링'의 과정을 거쳐서 진행되었다.
    1) 테스트를 먼저 작성한다.
    2) 테스트를 통과시킬 만큼 코드를 작성한다.
       작성한 코드가 통과하지 못하면 테스트를 통과할 만큼만 코드를 작성한다.
    3) 리팩토링으로 마무리하는 과정을 반복한다.
       이 과정을 반복하면서 점진적으로 기능을 완성해 나가는 것이 TDD의 전형적인 흐름이다.

#레드-그린-리팩터#
이러한 TDD의 사이클을 레드(Red)-그린(Green)-리팩터(Refactor)로 부르기도 한다.
레드는 테스트 코드가 실패하면 빨간색을 이용해서 실패한 테스트를 보여주는데서 비롯했다.
그린도 위와 마찬가지로 유래하였고 실패한 테스트를 통과시키는 것을 의미한다.
리팩터는 이름 그대로 리팩토링 과정을 의미한다.

#테스트가 개발을 주도#
테스트 코드를 먼저 작성하면 테스트가 개발을 주도하게 된다.
테스트를 작성하는 과정에서 구현을 생각하지 않았다.
단지 해당 기능이 올바르게 동작하는지 검증할 수 있는 테스트 코드를 만들었을 뿐이다.

테스트를 추가한 뒤에는 테스트를 통과시킬 만큼 기능을 구현했다.
지금까지 작성한 테스트를 통과할 만큼만 구현을 진행했다.
테스트 코드를 만들면 다음 개발 범위가 정해진다.
테스트 코드가 추가되면서 검증하는 범위가 넓어질수록 구현도 점점 완성되어 간다.
이렇게 테스트가 개발을 주도해 나간다.

#지속적인 코드 정리#
구현을 완료한 뒤에는 리팩토링을 진행했다.
리팩토링할 대상이 눈에 들어오면 리팩토링을 진행해서 코드를 정리했다.
당장 리팩토링할 대상이나 어떻게 리팩토링해야 할지 생각나지 않으면 다음 테스트를 진행한다.
테스트 코드 자체도 리팩토링 대상에 넣었다.

당장 리팩토링을 하지 않더라도 테스트 코드가 있다면 리팩토링을 보다 과감하게 진행할 수 있다.
잘 동작하는 코드를 수정하는 것은 심리적으로 불안감을 주지만 해당 기능이 온전하게 동작한다는 것을 검증해주는
테스트가 있으면 코드 수정에 대한 심리적 불안감을 줄여준다. 리팩토링을 통한 개선을 원활하게 할 수 있게 도와준다.

TDD는 개발 과정에서 지속적으로 코드 정리를 하므로 코드 품질이 급격히 나빠지지 않게 막아주는 효과가 있다.
이는 향후 유지보수 비용을 낮추는데 기여한다.

#빠른 피드백#
TDD가 주는 이점은 코드 수정에 대한 피드백이 빠르다는 점이다.
새로운 코드를 추가하거나 기존 코드를 수정하면 테스트를 돌려서 해당코드가 올바른지 바로 확인할 수 있다.
이는 잘못된 코드가 배포되는 것을 방지한다.

- [x] ch03 - '테스트 코드 작성순서'
  TDD에서 테스트 코드를 작성한 순서는 다음과 같다.

)쉬운 경우에서 어려운 경우로 진행
)예외적인 경우에서 정상인 경우로 진행
이 순서의 반대로 진행할 경우 구현 과정이 원활하게 진행되지 않기도 한다.

*초반에 복잡한 테스트부터 시작하면 안되는 이유

만일 초반부터 다양한 조합을 검사하는 복잡한 상황을 테스트로 추가하면 해당 테스트를 통과시키기 위해
한 번에 구현해야할 코드가 많아진다.

예를 들어 암호 검사 기능에서 '모든 규칙을 충족하는 경우'를 먼저 테스트로 추가해서 코드를 작성한다고 하자.
"abcDef12"란 암호가 기능을 통과시키는 것은 쉽다. 그냥 PasswordStrength.STRONG을 리턴하면 되기 때문이다.
하지만 "aZcDef12"란 암호가 기능을 통과시키게 하려면 if문을 늘려서 작성할 수 없으니
위의 암호와 공통적으로 작성하는 기능을 찾아서 작성해야 한다. 하지만 그러면 코드가 복잡해진다.
하지만 모든 조건을 충족하는지 확인하는 코드를 한 번에 구현하기란 쉽지 않다.
또한 한 번에 많은 코드를 만들다 보면 나도 모르게 버그를 만들고 나중에 버그를 잡기 위해 많은 시간을 허비하게 된다.

*구현하기 쉬운 테스트부터 시작하기
가장 구현하기 쉬운 경우부터 시작하면 빠르게 테스트를 통과시킬 수 있다.
보통 수 분에서 십여 분 이내에 구현을 완료해서 테스트를 통과시킬 수 있을 만큼 쉬운 것을 선택한다.

암호 검사 기능을 예시로 들면 '모든 조건을 충족하는 경우', '모든 조건을 충족하지 않는 경우'가 쉬울 것이다.
전자는 STRONG을 리턴하면 되고 후자는 WEAK를 리턴하면 된다.

첫 번째 테스트(가장 쉬운 테스트)를 통과시킨 뒤에는 '강함'에 해당하는 예를 추가해도 된다.
예를 들어 "abc1!Add"같은 코드를 추가한다.

그 다음도 역시 구현하기 쉬운 것이 선택기준이다.
위에서 '모든 조건을 충족하는 경우'를 검사했으므로 그 다음은 '한 규칙만 충족하는 경우'나 '두 규칙만 충족하는 경우'가
쉬울 것이다. '모든 규칙을 충족하지 않는 경우'는 정반대의 기능이 필요하므로 상대적으로 구현하기 어려울 것이다.

또한 '대문자 포함여부를 검사', '숫자 포함 여부를 검사'하는 것보다 '8글자 이상인지 검사'하는 것이 더 쉬울 것이다.
따라서 다음과 같이 테스트를 작성하면 쉬울 것이다.

'길이만 8글자 미만이고 나머지 규칙은 충족하는 암호의 강도는 보통'
'길이가 8글자 이상이고 나머지 규칙은 충족하지 않은 암호의 강도는 약함'

둘 다 길이가 8글자 이상인지 여부를 판단하는 로직만 구현하면 테스트를 통과시킬 수 있다.
이런 식으로 하나의 테스트를 통과했으면 그 다음으로 구현하기 쉬운 테스트를 선택해야 한다.
보통 수 분 내에 구현을 완료하고 통과시킬 수 있는 테스트를 선택해야 한다.
한 번에 구현하는 시간이 짧아지면 디버깅할 때에 유리하다.
코드가 짧기 때문에 디버깅할 때 문제 원인을 빠르게 찾을 수 있기 때문이다.

*예외 상황을 먼저 테스트해야 하는 이유
예외 상황을 전혀 고려하지 않은 코드에 예외 상황을 반영하려면 코드의 구조를 뒤집거나
코드 중간에 예외 상황을 처리하기 위해 조건문을 중복해서 추가하는 일이 벌어진다.
이는 코드를 복잡하게 만들어 버그 발생 가능성을 높인다.

그래서 초반에 예외 상황을 테스트하면 이런 가능성이 줄어든다.
예외 상황에 따른 if-else 구조가 미리 만들어지기 때문에 코드 구조가 덜 바뀐다.
또한 TDD를 하는 동안 예외 상황을 찾고 테스트에 반영하면 예외 상황을 처리하지 않아 발생하는 버그도 줄여준다.

*완급조절
처음 TDD를 접할 때 한 번에 얼마만큼의 코드를 작성할 것인가가 어렵다. 다음 단계에 따라 TDD를 익혀보자.
1 정해진 값을 리턴
2 값 비교를 이용해서 정해진 값을 리턴
3 다양한 테스트를 추가하면서 구현을 일반화

뻔한 구현이지만 위와 같은 구현과정을 거쳐 연습한다면 구현과정이 막히더라도 조금씩 기능을 구현해 나갈 수 있다.
TDD가 익숙해지면 상황에 따라 구현 속도를 조절할 수 있게 된다.
단순 덧셈, 길이비교와 같은 명백한 구현은 상수를 사용하지 않고 바로 구현하면 된다.

*지속적인 리팩토링
테스틀 통과한 뒤에는 리팩토링을 진행한다.
매번 리팩토링을 진행해야 하는 것은 아니지만 적당한 후보가 보이면 리팩토링을 진행한다.
코드 중복은 대표적인 리팩토링 대상이다.
코드가 길어지면 메서드 추출과 같은 기법을 사용해서 메서드 이름으로 코드의 이름을 표현할 수 있다.

TDD를 진행하는 과정에서 지속적으로 리팩토링을 진행하면 코드 가독성이 높아진다.

-> 일단 동작하는 코드를 만드는 능력이 중요하다.
하지만 소프트웨어 생존 시간이 길어질 수록 소프트웨어를 지속적으로 개선해야 한다.
그렇기 때문에 코드를 잘 변경하는 능력은 중요하다.
코드를 잘 변경하기 위해서는 변경하기 쉬운 구조를 가져야 하는데 이를 위한 것이 리팩토링이다.

-> 테스트 개상 코드에서 상수를 변수로 바꾸거나 변수 이름을 변경하는 것과 같은
작은 리팩토링은 발견하면 바로 실행한다.
반면, 메서드 추출과 같이 메서드의 구조에 영향을 주는 리팩토링은
큰 틀에서 구현 흐름이 눈에 들어오기 시작한 뒤에 진행한다.
왜냐하면 구현 초기에는 구현의 전반적인 흐름을 모르기 때문에 잘못된 리팩토링을 진행할 수 있기 때문이다.

*리팩토링시 테스트 코드의 중복 제거는 고민이 필요하다.
왜냐하면 각 테스트 메서드는 스스로 무엇을 테스트 하는지 명확하게 설명할 수 있어야 하기 때문이다.
테스트 코드의 구현 중복을 기계적으로 제거하면 자칫 테스트 메서드가 검증하고 싶은 내용을 알아보기 힘들 수 있다.
만일 중복을 제거한 후 테스트 코드가 여전히 자신을 설명하고 있다면 제거해도 된다.

*메서드의 파라미터가 세 개 이상이면 객체로 바꿔 한 개로 줄이는 것을 고려해야 한다.

*테스트할 목록 정리하기
TDD를 시작할 때 테스트할 목록을 미리 정리하면 좋다. 예를 들어

-1만원 납부하면 한 달 뒤가 만료일
-달의 마지막 날에 납부하면 다음달 마지막 날이 만료일
-2만원 납부하면 2개월 뒤가 만료일
-3만원 납부하면 3개월 뒤가 만료일
-10만원 납부하면 1년 뒤가 만료일

테스트할 내용을 정리했다면 이 중 어떤 테스트가 구현이 쉬울지 생각하고 어떤 테스트가 예외적인지 상상해본다.
테스트 과정에서 새로운 테스트 사례를 발견하면 그 사례를 목록에 추가해서 놓치지 않도록 해야 한다.
-지라, 트렐로 혹은 실패하는 테스트(레드)로 등록해 놓으면 새로운 사례를 놓치지 않는 방법이 된다.

테스트 목록을 적었다고 해서 테스트를 한 번에 다 작성하면 안된다.
한 번에 작성한 테스트 코드가 많으면 구현 초기에 리팩토링하기 힘들다.

또한 테스트를 통과시키기 전까지 계속해서 깨지는 테스트가 존재하므로 개발 리듬을 유지하는 데 도움이 안된다.
비교적 짧은 리듬이 개발 주기도 짧고 개발 집중력도 높아진다.

TDD로 개발하다 리팩토링 거리가 큰 경우도 있는데 이러한 것은 리팩토링하는데 시간이 오래걸리므로 TDD흐름이 깨지기 쉽다.
이때 리팩토링을 진행하지 말고 테스트를 통과시키는데 집중하고 할 일 목록에 추가해서 놓치지 않고 진행할 수 있도록 만든다.
또한 리팩토링 범위가 크면 리팩토링에 실패할 수도 있다. 그러니 코드를 커밋하는 걸 잊지 말거나 별도의 브랜치에서 리팩토링을 진행하자.
그래야 리팩토링이 실패해도 다시 동작하는 마지막 상태로 쉽게 돌아올 수 있다.

*시작이 안될 때는 단언부터 고민
테스트코드를 작성하다보면 시작이 잘 안될 때가 있다. 이럴 때는 검증하는 코드부터 작성하기 시작하면 도움이 된다.

*구현이 막히면
TDD를 진행하다보면 구현이 막힐 때가 있는데, 이럴 땐 과감하게 코드를 지우고 미련없이 다시 시작한다.
어떤 순서로 테스트 코드를 작성했는지 돌이켜보고 순서를 바꿔 다시 진행한다.

- [ ] ch03 - 'JUnit5 기초'
  JUnit 5는 크게 세 개의 요소로 구성되어 있다.
  ) JUnit 플랫폼 : 테스팅 프레임워크를 구동하기 위한 런처와 테스트 엔진을 위한 API를 제공한다.
  ) JUnit 주피터(Jupiter) : JUnit 5를 위한 테스트 API와 실행 엔진을 제공한다.
  ) JUnit 빈티지(Vintage) : JUnit 3과 4로 작성된 테스트를 JUnit 5 플랫폼에서 실행하기 위한 모듈을 제공한다.
  ) 




