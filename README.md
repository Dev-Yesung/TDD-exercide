# 📝'테스트 주도 개발 시작하기(최범균 저)'

## 👀 책을 공부한 진도를 체크하는 README 입니다.

### 🧐 현재 진도

ch01, 02, 03 중간까지 완료 ( ~ 23/1/26)
ch03 완료 (23/1/28)
ch04 ~ 06 완료 (23/2/3)
ch07 완료 (23/2/6)
ch08 완료 (23/2/7)
ch09 완료 (23/2/12)
ch11 완료 (23/2/12)
ch10 챕터 시작부터 228p까지 완료(23/2/12 ~)

- [x] ch02 - 'TDD시작' : 암호 강도 검사 기능
  정리 : 암호 강도 검사 기능을 TDD로 구현하였는데,
  그 과정은 '테스트 > 코딩 > 리팩토링'의 과정을 거쳐서 진행되었다.
    1) 테스트를 먼저 작성한다.
    2) 테스트를 통과시킬 만큼 코드를 작성한다.
       작성한 코드가 통과하지 못하면 테스트를 통과할 만큼만 코드를 작성한다.
    3) 리팩토링으로 마무리하는 과정을 반복한다.
       이 과정을 반복하면서 점진적으로 기능을 완성해 나가는 것이 TDD의 전형적인 흐름이다.

#레드-그린-리팩터#
이러한 TDD의 사이클을 레드(Red)-그린(Green)-리팩터(Refactor)로 부르기도 한다.
레드는 테스트 코드가 실패하면 빨간색을 이용해서 실패한 테스트를 보여주는데서 비롯했다.
그린도 위와 마찬가지로 유래하였고 실패한 테스트를 통과시키는 것을 의미한다.
리팩터는 이름 그대로 리팩토링 과정을 의미한다.

#테스트가 개발을 주도#
테스트 코드를 먼저 작성하면 테스트가 개발을 주도하게 된다.
테스트를 작성하는 과정에서 구현을 생각하지 않았다.
단지 해당 기능이 올바르게 동작하는지 검증할 수 있는 테스트 코드를 만들었을 뿐이다.

테스트를 추가한 뒤에는 테스트를 통과시킬 만큼 기능을 구현했다.
지금까지 작성한 테스트를 통과할 만큼만 구현을 진행했다.
테스트 코드를 만들면 다음 개발 범위가 정해진다.
테스트 코드가 추가되면서 검증하는 범위가 넓어질수록 구현도 점점 완성되어 간다.
이렇게 테스트가 개발을 주도해 나간다.

#지속적인 코드 정리#
구현을 완료한 뒤에는 리팩토링을 진행했다.
리팩토링할 대상이 눈에 들어오면 리팩토링을 진행해서 코드를 정리했다.
당장 리팩토링할 대상이나 어떻게 리팩토링해야 할지 생각나지 않으면 다음 테스트를 진행한다.
테스트 코드 자체도 리팩토링 대상에 넣었다.

당장 리팩토링을 하지 않더라도 테스트 코드가 있다면 리팩토링을 보다 과감하게 진행할 수 있다.
잘 동작하는 코드를 수정하는 것은 심리적으로 불안감을 주지만 해당 기능이 온전하게 동작한다는 것을 검증해주는
테스트가 있으면 코드 수정에 대한 심리적 불안감을 줄여준다. 리팩토링을 통한 개선을 원활하게 할 수 있게 도와준다.

TDD는 개발 과정에서 지속적으로 코드 정리를 하므로 코드 품질이 급격히 나빠지지 않게 막아주는 효과가 있다.
이는 향후 유지보수 비용을 낮추는데 기여한다.

#빠른 피드백#
TDD가 주는 이점은 코드 수정에 대한 피드백이 빠르다는 점이다.
새로운 코드를 추가하거나 기존 코드를 수정하면 테스트를 돌려서 해당코드가 올바른지 바로 확인할 수 있다.
이는 잘못된 코드가 배포되는 것을 방지한다.

- [x] ch03 - '테스트 코드 작성순서'
  TDD에서 테스트 코드를 작성한 순서는 다음과 같다.

)쉬운 경우에서 어려운 경우로 진행
)예외적인 경우에서 정상인 경우로 진행
이 순서의 반대로 진행할 경우 구현 과정이 원활하게 진행되지 않기도 한다.

*초반에 복잡한 테스트부터 시작하면 안되는 이유

만일 초반부터 다양한 조합을 검사하는 복잡한 상황을 테스트로 추가하면 해당 테스트를 통과시키기 위해
한 번에 구현해야할 코드가 많아진다.

예를 들어 암호 검사 기능에서 '모든 규칙을 충족하는 경우'를 먼저 테스트로 추가해서 코드를 작성한다고 하자.
"abcDef12"란 암호가 기능을 통과시키는 것은 쉽다. 그냥 PasswordStrength.STRONG을 리턴하면 되기 때문이다.
하지만 "aZcDef12"란 암호가 기능을 통과시키게 하려면 if문을 늘려서 작성할 수 없으니
위의 암호와 공통적으로 작성하는 기능을 찾아서 작성해야 한다. 하지만 그러면 코드가 복잡해진다.
하지만 모든 조건을 충족하는지 확인하는 코드를 한 번에 구현하기란 쉽지 않다.
또한 한 번에 많은 코드를 만들다 보면 나도 모르게 버그를 만들고 나중에 버그를 잡기 위해 많은 시간을 허비하게 된다.

*구현하기 쉬운 테스트부터 시작하기
가장 구현하기 쉬운 경우부터 시작하면 빠르게 테스트를 통과시킬 수 있다.
보통 수 분에서 십여 분 이내에 구현을 완료해서 테스트를 통과시킬 수 있을 만큼 쉬운 것을 선택한다.

암호 검사 기능을 예시로 들면 '모든 조건을 충족하는 경우', '모든 조건을 충족하지 않는 경우'가 쉬울 것이다.
전자는 STRONG을 리턴하면 되고 후자는 WEAK를 리턴하면 된다.

첫 번째 테스트(가장 쉬운 테스트)를 통과시킨 뒤에는 '강함'에 해당하는 예를 추가해도 된다.
예를 들어 "abc1!Add"같은 코드를 추가한다.

그 다음도 역시 구현하기 쉬운 것이 선택기준이다.
위에서 '모든 조건을 충족하는 경우'를 검사했으므로 그 다음은 '한 규칙만 충족하는 경우'나 '두 규칙만 충족하는 경우'가
쉬울 것이다. '모든 규칙을 충족하지 않는 경우'는 정반대의 기능이 필요하므로 상대적으로 구현하기 어려울 것이다.

또한 '대문자 포함여부를 검사', '숫자 포함 여부를 검사'하는 것보다 '8글자 이상인지 검사'하는 것이 더 쉬울 것이다.
따라서 다음과 같이 테스트를 작성하면 쉬울 것이다.

'길이만 8글자 미만이고 나머지 규칙은 충족하는 암호의 강도는 보통'
'길이가 8글자 이상이고 나머지 규칙은 충족하지 않은 암호의 강도는 약함'

둘 다 길이가 8글자 이상인지 여부를 판단하는 로직만 구현하면 테스트를 통과시킬 수 있다.
이런 식으로 하나의 테스트를 통과했으면 그 다음으로 구현하기 쉬운 테스트를 선택해야 한다.
보통 수 분 내에 구현을 완료하고 통과시킬 수 있는 테스트를 선택해야 한다.
한 번에 구현하는 시간이 짧아지면 디버깅할 때에 유리하다.
코드가 짧기 때문에 디버깅할 때 문제 원인을 빠르게 찾을 수 있기 때문이다.

*예외 상황을 먼저 테스트해야 하는 이유
예외 상황을 전혀 고려하지 않은 코드에 예외 상황을 반영하려면 코드의 구조를 뒤집거나
코드 중간에 예외 상황을 처리하기 위해 조건문을 중복해서 추가하는 일이 벌어진다.
이는 코드를 복잡하게 만들어 버그 발생 가능성을 높인다.

그래서 초반에 예외 상황을 테스트하면 이런 가능성이 줄어든다.
예외 상황에 따른 if-else 구조가 미리 만들어지기 때문에 코드 구조가 덜 바뀐다.
또한 TDD를 하는 동안 예외 상황을 찾고 테스트에 반영하면 예외 상황을 처리하지 않아 발생하는 버그도 줄여준다.

*완급조절
처음 TDD를 접할 때 한 번에 얼마만큼의 코드를 작성할 것인가가 어렵다. 다음 단계에 따라 TDD를 익혀보자.
1 정해진 값을 리턴
2 값 비교를 이용해서 정해진 값을 리턴
3 다양한 테스트를 추가하면서 구현을 일반화

뻔한 구현이지만 위와 같은 구현과정을 거쳐 연습한다면 구현과정이 막히더라도 조금씩 기능을 구현해 나갈 수 있다.
TDD가 익숙해지면 상황에 따라 구현 속도를 조절할 수 있게 된다.
단순 덧셈, 길이비교와 같은 명백한 구현은 상수를 사용하지 않고 바로 구현하면 된다.

*지속적인 리팩토링
테스틀 통과한 뒤에는 리팩토링을 진행한다.
매번 리팩토링을 진행해야 하는 것은 아니지만 적당한 후보가 보이면 리팩토링을 진행한다.
코드 중복은 대표적인 리팩토링 대상이다.
코드가 길어지면 메서드 추출과 같은 기법을 사용해서 메서드 이름으로 코드의 이름을 표현할 수 있다.

TDD를 진행하는 과정에서 지속적으로 리팩토링을 진행하면 코드 가독성이 높아진다.

-> 일단 동작하는 코드를 만드는 능력이 중요하다.
하지만 소프트웨어 생존 시간이 길어질 수록 소프트웨어를 지속적으로 개선해야 한다.
그렇기 때문에 코드를 잘 변경하는 능력은 중요하다.
코드를 잘 변경하기 위해서는 변경하기 쉬운 구조를 가져야 하는데 이를 위한 것이 리팩토링이다.

-> 테스트 개상 코드에서 상수를 변수로 바꾸거나 변수 이름을 변경하는 것과 같은
작은 리팩토링은 발견하면 바로 실행한다.
반면, 메서드 추출과 같이 메서드의 구조에 영향을 주는 리팩토링은
큰 틀에서 구현 흐름이 눈에 들어오기 시작한 뒤에 진행한다.
왜냐하면 구현 초기에는 구현의 전반적인 흐름을 모르기 때문에 잘못된 리팩토링을 진행할 수 있기 때문이다.

*리팩토링시 테스트 코드의 중복 제거는 고민이 필요하다.
왜냐하면 각 테스트 메서드는 스스로 무엇을 테스트 하는지 명확하게 설명할 수 있어야 하기 때문이다.
테스트 코드의 구현 중복을 기계적으로 제거하면 자칫 테스트 메서드가 검증하고 싶은 내용을 알아보기 힘들 수 있다.
만일 중복을 제거한 후 테스트 코드가 여전히 자신을 설명하고 있다면 제거해도 된다.

*메서드의 파라미터가 세 개 이상이면 객체로 바꿔 한 개로 줄이는 것을 고려해야 한다.

*테스트할 목록 정리하기
TDD를 시작할 때 테스트할 목록을 미리 정리하면 좋다. 예를 들어

-1만원 납부하면 한 달 뒤가 만료일
-달의 마지막 날에 납부하면 다음달 마지막 날이 만료일
-2만원 납부하면 2개월 뒤가 만료일
-3만원 납부하면 3개월 뒤가 만료일
-10만원 납부하면 1년 뒤가 만료일

테스트할 내용을 정리했다면 이 중 어떤 테스트가 구현이 쉬울지 생각하고 어떤 테스트가 예외적인지 상상해본다.
테스트 과정에서 새로운 테스트 사례를 발견하면 그 사례를 목록에 추가해서 놓치지 않도록 해야 한다.
-지라, 트렐로 혹은 실패하는 테스트(레드)로 등록해 놓으면 새로운 사례를 놓치지 않는 방법이 된다.

테스트 목록을 적었다고 해서 테스트를 한 번에 다 작성하면 안된다.
한 번에 작성한 테스트 코드가 많으면 구현 초기에 리팩토링하기 힘들다.

또한 테스트를 통과시키기 전까지 계속해서 깨지는 테스트가 존재하므로 개발 리듬을 유지하는 데 도움이 안된다.
비교적 짧은 리듬이 개발 주기도 짧고 개발 집중력도 높아진다.

TDD로 개발하다 리팩토링 거리가 큰 경우도 있는데 이러한 것은 리팩토링하는데 시간이 오래걸리므로 TDD흐름이 깨지기 쉽다.
이때 리팩토링을 진행하지 말고 테스트를 통과시키는데 집중하고 할 일 목록에 추가해서 놓치지 않고 진행할 수 있도록 만든다.
또한 리팩토링 범위가 크면 리팩토링에 실패할 수도 있다. 그러니 코드를 커밋하는 걸 잊지 말거나 별도의 브랜치에서 리팩토링을 진행하자.
그래야 리팩토링이 실패해도 다시 동작하는 마지막 상태로 쉽게 돌아올 수 있다.

*시작이 안될 때는 단언부터 고민
테스트코드를 작성하다보면 시작이 잘 안될 때가 있다. 이럴 때는 검증하는 코드부터 작성하기 시작하면 도움이 된다.

*구현이 막히면
TDD를 진행하다보면 구현이 막힐 때가 있는데, 이럴 땐 과감하게 코드를 지우고 미련없이 다시 시작한다.
어떤 순서로 테스트 코드를 작성했는지 돌이켜보고 순서를 바꿔 다시 진행한다.

- [x] ch05 - 'JUnit5 기초'
  JUnit 5는 크게 세 개의 요소로 구성되어 있다.
  ) JUnit 플랫폼 : 테스팅 프레임워크를 구동하기 위한 런처와 테스트 엔진을 위한 API를 제공한다.
  ) JUnit 주피터(Jupiter) : JUnit 5를 위한 테스트 API와 실행 엔진을 제공한다.
  ) JUnit 빈티지(Vintage) : JUnit 3과 4로 작성된 테스트를 JUnit 5 플랫폼에서 실행하기 위한 모듈을 제공한다.

@Test 애노테이션과 테스트 메서드
@Test 애노테이션을 붙이기만 하면 테스트 메서드가 된다.
테스트 클래스의 이름 작명하는 특별한 규칙은 없지만 보통 'Test'를 접미사로 붙인다.
이때 애노테이션이 붙은 메서드는 private이면 안된다.
JUnit의 Assertions 클래스는 assertEquals() 메서드와 같이 값을 검증하기 위한 목적의 다양한 정적 메서드를 제공한다.

주요 단언(assert)메서드
Assertions 클래스는 asserEquals()를 포함해 여러 단언 메서드를 제공한다.

(책의 표 참고)

주요 타입별로 assert메서드가 존재한다.(오버로딩되어 있음)
첫 번째 파라미터는 기대하는 값이고 두 번째 파라미터는 검사하려는 값이다.

fail()메서드는 테스트에 실패했음을 알리고 싶을 때 사용한다.

만일 익셉션 발생 유무가 검증 대상이라면 fail() 메서드를 사용하는 것보다
assertThrows()메서드를 이용해서 지정한 익셉션이 발생하는지 확인하는게 명확하다.
-> assertThrows(Class<T> expectdType, Executable exeecutable)
: executable을 실행한 결과로 지정한 타입의 익셉션이 발생하는지 검사한다.
-> assertDoesNotThrow(Executable executable)
: executable을 실행한 결과로 익셉션이 발생하지 않는지 검사한다.

**
executable 메서드는 다음과 같은 함수형 인터페이스이다.
public interface Executable {
void executable() throws Throwable;
}

assert 메서드는 실패하면 다음 코드를 실행하지 않고 바로 익셉션을 발생한다.

**경우에 따라 일단 모든 검증을 실행하고 그 중에 실패한 것이 있는지 확인하고 싶을 때가 있다.
이럴 때 사용할 수 있는 것이 asserAll()메서드이다.
(AssertJ의 경우에는 softAssertions.assertThat을 이용해서 테스트를 작성후
마지막에 assertAll 메서드를 사용하여 검증한다.)
https://sun-22.tistory.com/86 -> assertJ 참고

- [x] ch07 - '대역'
  대역의 필요성 : 테스트를 작성하다 보면 외부 요인이 필요한 시점이 있다.
  테스트 대상이 외부 요인에 의존하면 테스트를 작성하고 실행하기 어려워진다.
  TDD는 "테스트 작성 -> 통과시킬 만큼 구현 -> 리팩토링"의 과정을 짧은 흐름으로 반복해야 하는데,
  외부에서 테스트 데이터를 제공하지 않으면 테스트를 진행할 수 없게 된다.
  또한 외부 요인은 테스트 결과도 예측할 수 없게 만든다.
  이렇게 테스트 대상에서 의존하는 요인 때문에 테스트가 어려울 때는 대역을 써서 테스트를 진행할 수 있다.

** 영어로된 테스트 관련 글을 읽으면 test double이란 표현이 자주 나오는데,
여기서 double은 대역을 말하는 것이다.

대역의 종류
스텁(stub) : 구현을 단순한 것으로 대체한다. 테스트에 맞게 단순히 원하는 동작을 수행한다.
가짜(fake) : 제품에는 적합하지 않지만, 실제 동작하는 구현을 제공한다.
스파이(spy) : 호출된 내역을 기록한다. 기록한 내용은 테스트 결과를 검증할 때 사용한다. 스텁이기도 하다.
모의(mock) : 기대한 대로 상호작용하는지 행위를 검증한다. 기대한 대로 동작하지 않으면 익셉션을 발생할 수 있다.
모의 객체는 스텁이자 스파이도 된다.

TDD 과정에서 대역을 사용하지 않고 실제 구현을 사용하게 되면 개발하는데 대기시간이 길어질 수 있다.
대역을 사용하면 실제 구현이 없어도 다양한 상황에 대해 테스트할 수 있다.
또한 대역을 사용하면 실제 구현이 없어도 실행 결과를 확인할 수 있다.
즉, 대역은 의존하는 대상을 구현하지 않아도 테스트 대상을 완성할 수 있게 만들어주며 이는 대기 시간을 줄여주어 개발속도를 올리는 데 도움이 된다.

모의 객체는 스텁과 스파이를 지원하므로 대역으로 모의 객체를 많이 사용한다.
하지만 모의 객체를 과하게 사용하면 오히려 테스트 코드가 복잡해지는 경우도 발생한다.
모의 객체를 이용하면 대역 클래스를 만들지 않아도 되니까 처음에는 편할 수 있다.
하지만 결과 값을 확인하는 수단으로 모의 객체를 사용하기 시작하면 결과 검증 코드가 길어지고 복잡해진다.
특히 하나의 테스트를 위해 여러 모의 객체를 사용하기 시작하면 결과 검증 코드의 복잡도는 배로 증가한다.
게다가 모의 객체는 기본적으로 메서드 호출 여부를 검증하는 수단이기 때문에
테스트 대상과 모의 객체 간의 상호 작용이 조금만 바뀌어도 테스트가 깨지기 쉽다.
이런 이유로 모의 객체의 메서드 호출 여부를 결과 검증 수단으로 사용하는 것은 주의해야 한다.
특히 DAO나 리포지토리와 같이 저장소에 대한 대역은 모의 객체를 사용하는 것보다 메모리를 이용한 가짜 구현을 사용하는 것이
테스트 코드 관리에 유리핟. 물론 처음에는 가짜 대역을 구현해야 하니까 귀찮을 수 있는데,
일단 가짜 대역을 구현하면 모의 객체를 사용할 때 보다 테스트 코드가 간결해지고 관리하기 쉬워진다.

- [x] ch08 - '테스트 가능한 설계'
  모든 코드를 테스트할 수 있는 것은 아니다. 개발을 진행하다 보면 테스트하기 어려운 코드를 만나게 된다.
  파일을 읽기 위한 경로가 하드코딩으로 되어 있다면 해당 경로에 파일이 반드시 위치해야 된다.
  만약 운영체제가 다르다면 테스트할 수 없다. 테스트하려면 경로를 알맞게 수정해야 한다.
  하드코딩된 경로뿐만 아니라 하드 코딩된 IP 주소, 포트 번호도 테스트를 어렵게 만든다.

또한 의존 대상을 직접 생성하는 것도 테스트를 어렵게 만드는 또 다른 요인이다.
테스트를 실행하기 위해선 의존 대상의 실행환경을 구성해야 한다. 그렇지 않으면 테스트가 실패하기 때문이다

정적 메서드를 사용해도 테스트가 어려워질 수 있다.
만일 정적메서드가 서버와 통신해야할 경우 그 서버가 작동하고 있어야 한다.
또한 시스템 프로퍼티를 가져와 사용할 경우 시스템 프로퍼티도 테스트 환경에 맞게 설정해야 한다.
게다가 다양한 상황을 테스트하려면 그 테스트에 유효한 데이터를 가지고 테스트를 진행해야만 한다.

실행 시점에 따라 결과가 달라지면 테스트 코드를 작성하기 어렵다.
같은 테스트라도 어제까지는 문제 없이 성공하던 테스트가 오늘은 깨질 수도 있는 것이다.
Random을 이용해서 임의 값을 사용하는 코드도 비슷하다. Random이 생성한 값에 따라 실행결과가 달라질 수 있다.
이렇게 테스트를 실행하는 시점에 따라 테스트 결과가 달라진다면 그 테스트는 믿을 수 없게 된다.

역할이 섞여 있는 코드는 테스트하기 어렵다.
예를 들어 회원의 포인트 계산을 위한 메서드가 있는데, 고객의 정보를 DAO를 통해 가져오는 것이 메서드에 포함되어 있다.
DAO는 포인트 계산 자체와는 상관이 없다. 하지만 DAO가 포인트 계산 메서드에 포함되어 있는 것을 통해, 테스트하기 어렵게 만든다.
DAO가 작동하지 않으면 테스트가 불가능하기 때문이다. 즉, 포인트 계산이란 메서드에 불필요한 역할인 DAO로 데이터 불러오기가 섞여있기 때문에
테스트하기 어려운 코드가 되는 것이다.

그 외 테스트가 어려운 코드
이 외에 테스트 대상이 다음과 같다면 테스트가 어려울 수 있다.
1)메서드 중간에 소켓 통신 코드가 포함되어 있다.
2)콘솔에서 입력을 받거나 결과를 콘솔에 출력한다.
3)테스트 대상이 사용하는 의존 대상 클래스나 메서드가 final이다. 이 경우 대역으로 대체가 어려울 수 있다.
4)테스트 대상의 소스를 소유하고 있지 않아 수정이 어렵다.
** 소켓통신이나 HTTP통신은 실제를 대체할 서버를 로컬에 띄워서 처리할 수 있다. 서버 수준에서 대역을 사용한다고 생각하면 된다.

결국 테스트하기 어려운 주된 이유는 의존하는 코드를 교체할 수 있는 수단이 없기 때문이다.
상황에 따라 알맞은 방법을 적용하면 의존 코드를 교체할 수 있게 만들 수 있다.

1) 하드 코딩된 상수를 생성자나 메서드 파라미터로 받기
   하드 코딩된 경로의 테스트가 어려운 이유는 테스트 환경에 따라 경로를 다르게 줄 수 있는 수단이 없기 때문이다.
   하드 코딩된 상수 때문에 테스트가 힘들다면 해당 상수를 교체할 수 있는 기능을 추가하면 된다.
   쉬운 방법은 생성자나 세터를 이용해서 경로를 전달받는 것이다.
   **테스트 코드에서 데이터를 읽을 때 사용하는 파일은 소스 코드 리포지토리에 함께 등록해야 한다.
   src/test/resources 폴더가 테스트 용도의 파일을 저장하기에 적당한 위치이다.

2) 의존 대상을 주입 받기
   의존 대상은 주입 받을 수 있는 수단을 제공해서 교체할 수 있도록 한다. 생성자나 세터를 주입 수단으로 이용하면 된다.
   생성자나 세터를 통해 의존 대상을 교체할 수 있게 되면 실제 구현 대신에 대역을 사용할 수 있어 테스트를 보다 원활하게 작성할 수 있다.
   만일 레거시 코드에서 생성자 없는 버전을 사용하고 있다면, 기존의 코드는 그대로 유지하고 세터를 이용해서 의존 대상을 교체할 수 있도록 하면 된다.

3) 테스트하고 싶은 코드를 분리하기
   역할이 섞여있는 상태에서 기능의 일부만 테스트하고 싶다면 해당 코드를 별도 기능으로 분리해서 테스트를 진행할 수 있다.
   그리고 그 기능을 테스트할 때 필요한 값들을 파라미터로 받는 방식으로 리팩토링한다.
   만일 테스트하고 싶은 기능 자체를 대역으로 변경하고 싶다면 '의존 대상을 주입 받기'에서 설명한 것처럼 세터를 이용해서 의존대상을 주입할 수 있게 하면 된다.

4) 시간이나 임의 값 생성 기능 분리하기
   테스트 대상이 시간이나 임의 값을 사용하면 테스트 시점에 따라 테스트 결과가 달라진다.
   이 경우 테스트 대상이 사용하는 시간이나 임의 값을 제공하는 기능을 별도로 분리해서 테스트 가능성을 높일 수 있다.
   만일 현재 일자를 필요로하는 기능이 있다면 현재 일자를 구하는 기능을 기존 메서드에서 분리하고 분리한 대상을 주입할 수 있게 변경하면
   테스트를 원하는 상황으로 쉽게 제어할 수 있다.
   임의 값도 비슷하다.
   임의 값을 제공하는 라이브러리를 직접 사용하지 말고 별도로 분리한 타입을 사용해서 대역으로 처리할 수 있어야 테스트 가능하게 만들 수 있다.

5) 외부 라이브러리는 직접 사용하지 말고 감싸서 사용하기
   테스트 대상이 사용하는 외부 라이브러리를 쉽게 대체할 수 없는 경우도 있다.
   외부 라이브러리가 정적 메서드를 제공한다면 대체할 수 없다.
   대역으로 대체하기 어려운 외부 라이브러리가 있다면 외부 라이브러리를 직접 사용하지 말고 외부 라이브러리와 연동하기 위한 타입을 따로 만든다.
   그리고 테스트 대상은 이렇게 분리한 타입을 사용하게 바꾼다.
   테스트 대상 코드는 새로 분리한 타입을 사용함으로써 외부 연동이 필요한 기능을 쉽게 대역으로 대체할 수 있게 된다.
   의존하는 대상이 final 클래스이거나 의존 대상의 호출 메서드가 final이어서 대역으로 재정의 할 수 없는 경우에도 동일한 기법을 적용해서 테스트 가능하게 만들 수 있다.

- [x] ch09 - '테스트 범위와 종류'
  테스트는 '기능 테스트, 통합 테스트, 단위 테스트' 3가지 테스트로 나눠볼 수 있다.

테스트 관련 용어는 문맥이나 사용자에 따라 의미가 다를 때도 있다.
예를 들어 개발 완료 후에 진행하는 최종 테스트를 '통합 테스트'라고 부르기도 한다.
고객의 입장에서 요구한 기능을 올바르게 구현했는지 수행하는 테스트를 '인수 테스트'라고 부르는데,
요건을 완료했는지 정의하기 위해 작성한 테스트를 '인수 테스트'라고 부르기도 한다.

기능 테스트(Functional Testing)는 사용자 입장에서 시스템이 제공하는 기능이 올바르게 동작하는지 확인한다.
이 테스트를 수행하려면 시스템을 구동하고 사용하는데 필요한 모든 구성요소가 필요하다.
기능 테스트는 사용자가 직접사용하는 웹 브라우저나 모바일 앱부터 시작해서 데이터베이스나 외부 서비스에 이르기까지
모든 구성 요소를 하나로 엮어서 진행한다. 이는 끝(브라우저)에서 끝(데이터베이스)까지 모든 구성요소를 논리적으로
완전한 하나의 기능으로 다룬다. 기능 테스트는 끝에서 끝까지 올바른지 검사하기 때문에 E2E(End to end) 테스트로도 볼 수 있다.
QA 조직에서 수행하는 테스트가 주로 기능 테스트이다. 이때 테스트는 시스템이 필요로 하는 데이터를 입력하고 결과가 올바른지 확인한다.

기능 테스트를 자동화했다면 DB에 보관된 데이터를 삭제하거나 수정하는 것과 같이
DB 데이터를 테스트 코드에서 조작할 수 있지만, 이는 반복적인 기능 테스트를 위한 것이지 기능 테스트 결과를 검증하기 위한 용도는 아니다.
보통의 기능 테스트라면 회원 가입을 실행한 후에 데이터가 올바르게 들어갔는지 확인하기 위해 개인 정보 조회 화면을 실행하거나
관리 도구의 회원 정보 조회 기능을 실행할 것이다.
부득이한 경우를 제외하면 기능 테스트는 사용자와 동일한 방식으로 기능을 검증해야 한다.

통합 테스트(Integration Testing)는 시스템의 각 구성요소가 올바르게 연동되는지 확인한다.
기능 테스트가 사용자 입장에서 테스트하는데 반해 통합 테스트는 소프트웨어의 코드를 직접 테스트한다.
모바일 앱을 예로 들면기능 테스트는 앱을 통해 가입 기능을 테스트한다면 통합 테스트는 서버의 회원 가입 코드를 직접 테스트하는 식이다.

단위 테스트(Unit Testing)는 개별 코드나 컴포넌트가 기대한대로 동작하는지 확인한다.
지금까지 이 책에서 살펴본 테스트가 주로 단위 테스트 코드이다.
단위 테스트는 한 클래스나 한 메서드와 같은 작은 범위를 테스트한다.
일부 의존 대상은 스텁(Stub)이나 모의 객체(Mock)등을 이용해서 대역으로 대체한다.

각 테스트는 다음과 같은 차이가 있다.
> 통합테스트를 실행하려면 DB나 캐시 서버와 같은 연동 대상을 구성해야 한다.
> 기능 테스틀 실행하려면 웹 서버를 구동하거나 모바일 앱을 폰에 설치해야 할 수도 있다.
> 또한 통합 테스트나 기능 테스트는 테스트 상황을 만들어내기 위해 많은 노력이 필요하다.
> 반면에 단위테스트는 테스트 코드를 빼면 따로 준비할 것이 없다.

> 통합 테스트는 DB연결, 소켓 통신, 스프링 컨테이너 초기화와 같이 테스트 실행 속도를 느리게 만드는 요인이 많다.
> 기능 테스트는 추가로 브라우저나 앱을 구동하고 화면의 흐름에 따라 알맞은 상호 작용을 해야한다.
> 반면에 단위 테스트는 서버를 구동하거나 DB를 준비할 필요가 없다.
> 테스트 대상이 의존하는 기능을 대역으로 처리하면 되므로 테스트 실행 속도가 빠르다.

> 통합 테스트나 기능 테스트로는 상황을 준비하거나 결과 확인이 어렵거나 불가능할 때가 있다.
> 외부 시스템과 연동해야 하는 기능이 특히 그렇다.
> 이런 경우에는 단위테스트와 대역을 조합해서 상황을 만들고 결과를 확인해야 한다.

> TDD를 하느지 여부에 상관없이 테스트 코드를 작성하는 개발자는 단위 테스트와 통합 테스트를 섞어서 작성한다.
> 어떤 테스트를 더 많이 작성해야 한다는 절대적인 규칙은 없지만, 위와 같은 차이로 통합 테스트 코드보다는 단위 테스트 코드를 더 많이 작성한다.

> 통합 테스트를 실행하려면 준비할 것이 많고 단위테스트에 비해 실행 시간도 길지만, 그래도 통합 테스트는 필요하다.
> 아무리 단위 테스트를 많이 만든다고 해도 결국은 각 구성 요소가 올바르게 연동되는 것을 확인해야 하는데,
> 이를 자동화하기 좋은 수단이 통합 테스트 코드이기 때문이다.

기능 테스트를 수행하려면 브라우저나 모바일 앱과 같은 클라이언트부터 DB 까지 모든 환경이 갖춰져야 하기에 자동화하거나 다양한 상황별로 테스트하기 가장 어렵다.
이런 이유로 정기적으로 수행하는 기능 테스트는 정상적인 경우와 몇 가지 특수한 상황만 테스트 범위로 잡는다.
기능 테스트를 수행하기 위한 알맞은 도구가 없으면 기능 테스트 코드를 만들기 힘들 수도 있다.

통합 테스트는 기능 테스트에 비해 제약이 덜하다. 또한 시스템의 내부 구성요소에 대한 테스트도 가능하다.
통합 테스트는 기능 테스트에 비해 상대적으로 실행 시간이 짧고 상황을 보다 유연하게 구성할 수 있기 때문에 보통 기능 테스트보다 통합 테스트를 더 많이 작성한다.

단위 테스트는 통합 테스트로도 만들기 힘든 상황을 쉽게 구성할 수 있다.
더 작은 단위를 대상으로 테스트 코드를 만들고 더 다양한 상황을 다루기 때문에 통합 테스트보다 단위 테스트 코드를 더 많이 작성하게 된다.

기능 테스트나 통합 테스트에서 모든 예외 상황을 테스트하면 단위 테스트는 줄어든다.
왜냐하면 각 테스트가 다루는 내용이 중복되기 때문이다.
하지만 테스트 속도는 통합 테스트보다 단위 테스트가 빠르기 때문에 가능하면 단위 테스트에서 다양한 상황을 다루고,
통합 테스트나 기능 테스트는 주요 상황에 초점을 맞춰야 한다.
그래야 테스트 실행 시간이 증가해 피드백이 느려지는 것을 방지할 수 있다.
테스트 실행 속도가 느려지면 테스트를 작성하지 않거나 테스트 실행을 생략하는 상황이 벌어진다.
이는 결국 소프트웨어의 품질 저하로 이어질 수 있기 때문에 가능하면 빠른 시간 내에 테스트를 실행할 수 있도록 해야 한다.

소프트웨어는 다양한 외부 연동이 필요하다. 대부분 웹 어플리케이션은 DB 와의 연동을 필요로 한다.
HTTP 를 이용한 통신도 증가하고 있다. 카프카를 이용한 메시지 송수신도 늘어나고 있다.
외부 연동 대상은 쉽게 제어할 수 없기 때문에 연동해야할 대상이 늘어날수록 통합 테스트도 힘들어진다.
모든 외부 연동 대상을 통합 테스트에서 다룰 수 없지만, 일부 외부 대상은 어느 정도 수준에서 제어가 가능하다.

WireMock을 통한 REST 클라이언트 테스트
통합 테스트하기 어려운 대상이 외부 서버이다. WireMock을 사용하면 서버 API를 스텁으로 대체할 수 있다.
=> WireMock은 JSON/XML 응답, HTTPS 지원, 단독 실행 등 다양한 기능을 제공하므로 외부 연동 코드를 테스트할 때 유용하게 사용할 수 있다.
WireMock에 대한 보다 자세한 정보는 https://www.wiremock.org 사이트애서 얻을 수 있다.

스프링부트는 테스트에서 웹 환경을 구동할 수 있는 기능을 제공한다.
이 테스트는 이 기능을 사용해서 내장 서버를 구동하고 스프링 웹 어플리케이션을 실행한다.
TestRestTemplate는 스프링 부트가 테스트 목적으로 제공하는 것으로서 내장 서버에 연결하는 RestTemplate이다.

- [x] ch10 - '테스트 코드와 유지보수'
  빠른 서비스 출시를 위해 CI(Continuous Integration, 지속적 통합)과 CD(Continuous Delivery 혹은 Deployment, 지속적 전달 혹은
  배포)를
  도입하는 곳이 증가하고 있다. 지속적으로 코드를 통합하고 출시 가능한 상태로 만들고 배포하려면 새로 추가한 코드가 기존 기능을 망가뜨리지 않는지
  확인할 수 있어야 하며 이런 이유로 자동화 테스트는 CI/CD의 필수 요건 중 하나이다.
  TDD 를 하는 과정에서 작성한 테스트 코드는 CI/CD 에서 자동화테스트로 사용되어 버그가 배포되는 것을 막아주고
  이는 소프트웨어 품질이 저하되는 것을 방지한다.

테스트 코드는 그 자체로 코드이기 때문에 제품 코드와 동일하게 유지보수 대상이 된다.
테스트 코드를 유지보수하는 데 시가닝 많이 들기 시작하면 점점 테스트 코드를 손보지 않아 실패하는 테스트가 증가하게 된다.
깨지는 테스트를 방치하는 상황이 길어지면 테스트 코드는 가치를 잃어버리게 된다.

> 실패한 테스트가 새로 발생해도 무감각해진다.
> 테스트 실패 여부에 상관 없이 빌드하고 배포하기 시작한다.

> 빌드를 통과시키기 위해 실패한 테스트를 주석 처리하고 실패한 테스트는 고치지 않는다.

테스트 코드는 코드를 변경했을 때 기존 기능이 올바르게 동작하는지 확인하는 회귀 테스트(regression test)를 자동화하는 수단으로 사용되는데
깨진 테스트를 방치하기 시작하면 회귀 테스트가 검증하는 범위가 줄어든다.
이는 코드에 버그가 발생했을 때 이를 놓칠 가능성이 커지는 것을 의미한다. 즉, 소프트웨어 품질이 낮아질 가능성이 커지는 것이다.

실패한 테스트를 통과시키기 위해 많은 노력이 필요하면 점점 테스트 코드에서 멀어지고 TDD에서도 멀어진다.
테스트 코드를 만들지 않으면 테스트가 가능하지 않은 코드를 만들게 되고 이는 다시 테스트 코드 작성을 어렵게 만든다.
이런 악순환이 발생하지 않으려면 테스트 코드 자체의 유지보수성이 좋아야 한다.
테스트 코드를 유지보수하기 좋아야 지속적으로 테스트를 작성하게 되고 결과적으로 소프트웨어의 품질이 떨어지는 것도 막을 수 있다.

좋은 테스트 코드를 만들려면 몇 가지 주의해야 할 사항이 있다.
여기서는 TDD 를 처음 시도하는 개발자들이 빠지기 쉬운 실수와 주의 사항을 살펴볼 것이다.

> **변수나 필드를 사용해서 기댓값 표현하지 않기**
> 기대하는 값에 변수나 필드를 사용하지 않고 하드 코딩으로 직접 값을 사용하면
> 복잡하지 않고 기대하는 값도 명확하게 표현할 수 있다. 또 변수를 사용할 때처럼 메서드를 잘못 사용할 일도 없다.
> 또한 코드 가독성이 좋아져서 테스트 코드를 더욱 쉽게 파악할 수 있다.
> 객체나 필드, 변수에 어떤 값이 사용되었느지 알아보기 위해 필드와 변수를 오갈 필요가 없기 때문이다.

> **두 개 이상을 검증하지 않기**
> 처음 테스트 코드를 작성하면 한 테스트 메서드에 가능한 많은 단언을 하려고 시도한다.
> 그 과정에서 서로 다른 검증을 섞는 경우가 있다.
> 비록 테스트 알고리즘이 잘못되지 않았더라도 한 테스트에서 검증하는 내용이 두 개 이상이면 테스트 결과를 확인할 때 집중도가 떨어진다.
> 만약 첫 번째 검증이 실패하면 테스트는 거기서 멈춘다. 첫 번째 검증 대상을 통과시켜야 비로소 두 번째 검증이 성공했는지 여부를 확인할 수 있다.
> 또한 테스트에 실패했을 때 두 가지 검증 대상 중 무엇이 실패했는지 확인해야 한다.
> 한 테스트 메서드에서 서로 다른 내용을 검증한다면 각 검증 대상을 별도로 분리해서 테스트의 집중도를 높일 수 있다.
> 물론 테스트 메서드가 반드시 한 가지만 검증해야 하는 것은 아니지만, 검증 대상이 명확하게 구분된다면 테스트 메서드도 구분하는 것이 유지보수에 유리하다.

> **정확하게 일치하는 값으로 모의 객체 설정하지 않기**
> 테스트에서 특정한 값에 의한 검증이 아닌 임의의 값에 대한 검증을 해야 한다면 정확하게 일치하는 값으로 테스트를 하면 안된다.
> 모의 객체는 가능한 범용적인 값을 사용해서 기술해야 한다.
> 한정된 값에 일치하도록 모의 객체를 사용하면 약간의 코드 수정만으로도 테스트는 실패하게 된다.
> 이 경우 테스트 코드의 일부 값을 수정하면 모의 객체 관련 코드도 함께 수정하는 번거로움이 있다.
> 테스트의 의도를 해치지 않는 범위에서 특정한 값을 사용하기 보단 범용적인 값을 사용해야 한다.
> 이렇게 해야 약간의 코드 수정 때문에 테스트가 실패하는 것을 방지할 수 있다.
> 또한 테스트 코드를 수정할 때 모의 객체 관련 코드를 함께 수정해야 하는 빈도도 줄어든다.

> **과도하게 구현 검증하지 않기**
> 테스트 코드를 작성할 때 주의할 점은 테스트 대상의 내부 구현을 검증하는 것이다. 모의 객체를 처음 사용할 때 특히 이런 유혹에 빠지기 쉽다.
> 내부 구현을 검증하는 것이 나쁜 것은 아니지만 한 가지 단점이 있다.
> 그것은 바로 구현을 조금만 변경해도 테스트가 깨질 가능성이 커진다는 것이다.
> 내부 구현은 언제든지 바뀔 수 있기 때문에 테스트 코드는 내부 구현보다 실행 결과를 검증해야 한다.
> 이미 존재하는 코드에 단위 테스트를 추가하면 어쩔 수 없이 내부 구현을 검증해야할 때도 있다.
> 기능이 정상적으로 동작하는지 확인할 수단이 검증 밖에 없다면 모의 객체를 사용해서 테스트 코드를 작성해야 하지만
> 일단 테스트 코드를 작성한 뒤에는 점진적으로 코드를 리팩토링해서 구현이 아닌 결과를 검증할 수 있도록 시도해야 한다.
> 그렇게 함으로써 향후에 사소한 구현 변경으로 인해 테스트가 깨지는 것을 방지할 수 있고 또한 코드의 테스트 가능성도 높일 수 있다.

> **셋업을 이용해서 중복된 상황을 설정하지 않기**
> 테스트 코드를 작성하다 보면 각 테스트 코드에서 동일한 상황이 필요할 때가 있다.
> 이 경우 중복된 코드를 제거하기 위해 @BeforeEach 메서드를 이용해서 상황을 구성할 수 있다.
> 상황 구성을 위한 코드 중복을 제거하면 전체 테스트 코드의 길이가 짧아진다.
> 중복을 제거하고 코드 길이도 짧아져서 코드 품질이 좋아졌다고 생각할 수 있지만, 그렇지 않다.
> 만일 추후에 테스트가 실패하는 상황이 생긴다면 테스트에 실패한 니유를 분석해야 하고 그렇게 되면 setUp() 메서드를 확인해야 한다.
> 즉, 코드를 위아래로 이동하면서 실패한 원인을 분석해야 한다.
> 또한 테스트가 깨지기 쉬운 구조가 된다.
> 모든 테스트 메서드가 동일한 상황 코드를 공유하기 때문에 조금만 내용을 변경해도 테스트가 깨질 수 있다.
> 만일 셋업 메서드의 상황설정 코드가 변경되면 영향을 받는 테스트가 있기 때문이다.
> 테스트 메서드는 검증을 목표로 하는 하나의 완전한 프로그램이어야 한다.
> 각 테스트 메서드는 별도 프로그램으로서 검증 내용을 스스로 잘 설명할 수 있어야 한다.
> 그러기 위해서는 상황 구성코드가 테스트 메서드 안에 위치해야 한다.
> 그래야 테스트 메서드 스스로 완전하게 테스트 내용을 설명할 수 있다.
> 이럴 때는 상황 구성코드가 테스트 메서드 안에 위치하게 한다. 코드는 다소 길어졌지만, 테스트 메서드 자체는 스스로를 더 잘 설명하고 있다.
> 테스트에 실패해도 코드를 이리저리 왔다갔다 하면서 보지 않아도 된다. 실패한 테스트 메서드 위주로 코드를 보면 된다.
> 각 테스트에 맞게 상황을 설정하는 것도 쉽다. 한 테스트 메서드의 상황을 변경해도 다른 테스트에 영향을 주지 않기 때문이다.
> 셋업 메서드를 이용해서 여러 메서드에 동일한 상황을 적용하는 것이 처음에는 편리하지만,
> 시간이 지나면 테스트 코드를 이해하고 유지 보수하는데 오히려 방해 요소가 된다.
> 테스트는 자체적으로 검증하는 내용을 완전히 기술하고 있어야 테스트 코드를 유지보수하는 노력을 줄일 수 있다.

> **통합 테스트에서 데이터 공유 주의하기**
> DB 연동을 포함한 통합테스트를 실행하려면 DB 데이터를 알맞게 구성해야 한다.
> 이를 위한 방법은 테스트를 실행할 때마다 DB 데이터를 초기화하는 쿼리를 실행하는 것이다.
> 스프링 프레임워크를 사용하면 @Sql 애노테이션을 사용해서 테스트를 실행하기 전에 특정 쿼리를 실행할 수 있다.
> @Sql 애노테이션으로 sql 파일을 지정해서 테스트에 필요한 데이터를 초기화할 수 있다. 이는 곧 테스트를 위한 상황을 만들어 준다.
> 이를 통해 통합 테스트 메서드는 데이터 초기화를 위한 코드를 작성하지 않아도 된다.
> 물론 이 방식은 편리하지만 셋업 메서드를 이용한 상황 설정과 마찬가지로 초기화를 위한 쿼리 파일을 조금만 변경해도 많은 테스트가 깨질 수 있고
> 테스트가 깨지면 관련된 쿼리 파일을 같이 봐야하기 때문에 유지보수를 귀찮고 어렵게 만든다.
> 그래서 통합 테스트 코드를 만들 때는 다음과 같이 두 가지로 초기화 데이터를 나눠서 생각한다.
> 첫 번째 : 모든 테스트가 같은 값을 사용하는 데이터 e.g) 코드값 데이터
> 코드값 데이터는 거의 바뀌지 않는다. 모든 테스트가 동일한 코드값 데이터를 사용해도 문제가 없으며
> 오히려 서로 다른 코드값 데이터를 사용하면 문제가 발생할 수 있다.
> 이렇게 모든 테스트가 다른 값을 사용하면 안되는 데이터는 동일한 데이터를 공유해도 된다.
> 두 번째 : 테스트 메서드에서만 필요한 데이터 e.g) 중복 ID 검사를 위한 회원 데이터
> 특정 테스트 메서드에서만 의미 있는 데이터는 모든 테스트가 공유할 필요가 없다.
> 이런 데이터는 특정 테스트에서만 생성해서 테스트 코드가 완전한 하나가 되도록 해야 한다.

> **통합 테스트의 상황 설정을 위한 보조 클래스 사용하기**
> 위처럼 테스트 코드에서 상황설정을 위해 직접 쿼리를 실행하게 된다면 테스트 메서드를 분석하기는 좋아졌지만
> 상황을 만들기 위한 코드가 여러 테스트 코드에 중복된다.
> 테이블 이름이나 칼럼 이름이 바뀌면 여러 테스트 메서드를 수정해야 하므로 유지보수에 좋지 않다.
> 테스트 메서드에서 직접 상황을 구성하면서 코드 중복을 없애는 방법이 있는데,
> 그것은 바로 상황설정을 위한 보조 클래스를 사용하는 것이다.
> 상황 설정을 위한 보조 도구인 보조 클래스를 사용하면 메서드 이름을 사용하게 되어 어떤 상황을 구성하는지 이해할 수 있고
> 각 테스트 메서드에서 상황을 구성하기 위해 코드가 중복되는 것도 방지할 수 있다.
> 결과를 검증하는 코드도 동일하다. 통합 테스트에서 결과를 검증하는 코드는 직접 쿼리를 실행하고 그 값을 비교해야 한다.
> 검증을 위해 데이터를 조회하는 코드가 여러 테스트 메서드에 중복되어 있으면 유지보수에 좋지 않다.
> 이럴 때는 상황 설정과 동일하게 결과 검증을 위한 보조 클래스를 만들어 테스트 코드를 유지보수하기 좋은 코드로 만들수 있다.

> **실행 환경이 다르다고 실패하지 않기**
> 같은 테스트 메서드가 실행 환경에 따라 성공하거나 실패하면 안된다.
> 로컬 개발 환경에서는 성공하는데 빌드 서버에서는 실패한다거나 윈도우에서는 성공하는데 맥OS 에서는 실패하는 식으로
> 테스트를 실행하는 환경에 따라 테스트가 다르게 동작하면 안된다.
> 예를 들어 테스트에서 파일을 사용하기 위해 절대경로를 사용하는 경우이다.
> 이럴 경우 테스트에서 사용하는 파일은 프로젝트 폴더를 기준으로 상대경로를 사용해야 한다.
> 테스트 코드에서 파일을 생성하는 경우에도 특정 OS나 본인의 개발 환경에서만 올바르게 동작하지 않도록 주의해야 한다.
> 간혹 특정 OS 환경에서만 실행해야 하는 테스트도 있다. 이런 경우에는 JUnit5가 제공하는 @EnabledOnOs 애노테이션과
> @DisabledOnOs 애노테이션을 사용해서 OS에 따른 테스트 실행 여부를 지정하면 된다.

> **실행 시점이 다르다고 실패하지 않기**
> 테스트 코드에서 만료일을 체크해야 할 경우가 있다. 현재 시간을 기준으로 테스트를 진행할 경우 현재 시간이 만료일을 지난 경우 테스트가 깨진다.
> 이 경우에 시간을 파라미터로 전달 받아 비교하는 방법을 사용하는 것이 좋다.
> 만료일이 정해져있지만 테스트 날짜를 현재날짜가 아닌 파라미터로 전달해서 테스트하기 때문에 실행시점에 상관없이 항상 통과한다.
> 또한 시간을 전달하면 경계 조건도 쉽게 테스트할 수 있다.
> 시점을 제어하는 또 다른 방법으로는 별도의 시간 클래스를 작성하는 것이다.

> **랜덤하게 실패하지 않기**
> 실행 시점에 따라 테스트가 실패하는 또 다른 예는 랜덤 값을 사용하는 것이다.
> 랜덤 값에 따라 달라지는 결과를 검증할 때 주로 이런 문제가 발생한다.
> 랜덤하게 생성한 값이 결과 검증에 영향을 준다면 구조를 변경해야 테스트가 가능하다.
> 또는 랜덤 값 생성을 다른 객체에 위임하게 바꿔도 된다.
> 예를 들어 숫자 야구 게임에서 게임 숫자 생성을 위한 클래스를 별도로 만든다.
> 테스트 코드는 숫자 생성을 하는 클래스의 대역을 사용해서 원하는 값을 갖고 클래스를 테스트할 수 있다.

> **필요하지 않은 값은 설정하지 않기**
> 테스트에서 필요하지 않은 값은 설정할 필요가 없다.
> 예를 들어 중복 ID를 가진 회원은 가입할 수 없다는 것을 검증하기 위해서는 ID에 대해서만 테스트하면 된다.
> 굳이 이름, 이메일, 가입일과 같은 값은 필요하지 않다.
> 검증에 필요한 객체를 생성할 때에도 검증에 필요한 값만 지정하면 된다.
> 테스트에 필요한 값만 설정하면 필요하지 않은 값을 설정하느라 고민할 필요가 없다.
> 또한 테스트 코드가 짧아져서 한눈에 내용을 파악할 수 있다.

> **단위 테스트를 위한 객체 생성 보조 클래스**
> 단위테스트 코드를 작성하다 보면 상황 구성을 위해 필요한 데이터가 다소 복잡할 때가 있다.
> 테스트를 위한 객체 생성 클래스를 따로 만들면 이런 복잡함을 줄일 수 있다.
> 예를 들어 팩토리클래스를 만들어 복잡한 객체 생성을 편하게 만들면 다양한 상황에 대한 테스트 코드를 작성할 수 있다.
> 또는 빌더 패턴을 사용하여서 좀 더 유연하게 만들 수 있다. 빌더 패턴을 통해 원하는 값만 바꿔서 객체를 생성할 수 있다.
> 파라미터에 기본 값을 지원하는 언어(e.g 코틀린)를 사용하면 빌더와 팩토리 메서드를 하나로 합칠 수 있다.

> **조건부로 검증하지 않기**
> 테스트는 성공하거나 실패해야 한다.
> 테스트가 성공하거나 실패하려면 반드시 단언을 실행해야 한다.
> 만약 조건에 따라서 단언을 하지 않으면 그 테스트는 성공하지도 실패하지도 않은 테스트가 된다.
> 예를 들어 if 문을 사용하여 조건에 따라 단언을 실행할지 말지를 결정하게 된다면 잘못된 테스트가 된다.
> 또한 이렇게 조건문을 통해 실행하게 된다면 테스트가 실패해야하는 경우 실패하지 않아 문제가 생긴다.
> 조건에 따라 단언을 선언하는 것이 아니라 조건도 단언으로 선언해서 검증하는 방식으로 테스트를 바꾸자

> **통합 테스트는 필요하지 않은 범위까지 연동하지 않기**
> 예를 들어 dao만 테스트하면 되는데 @SpringBootTest를 통해 테스트하게 되면 테스트에 필요 없는
> 모든 컴포넌트들을 스프링이 초기화해야 한다. 이 경우 관련된 설정만 초기화하는 방법으로 @JdbcTest를 이용하면 된다.

> **더 이상 쓸모 없는 테스트 코드**
> 어떤 라이브러리, 클래스의 사용법을 몰라 테스트를 이용해 사용법을 익혔다면 그때 사용했던 코드는 삭제한다. 유지보수의 대상이 아니다.
> 단지 테스트 커버리지를 높이기 위한 목적으로 작성한 테스트 코드도 유지할 필요가 없다.
> 단순히 테스트 커버리지를 높이기 위한 단순한 검증 코드는 유지보수의 대상이 아니고 아무 도움도 안된다.
> 만일 테스트 커버리지를 높여야 한다면 실제로 테스트 코드가 다루지 않는 if-else 나 하위 타입 등을 찾아 테스트를 추가해야 한다.

> ***테스트 커버리지란 테스트하는 동안 실행하는 코드가 얼마나 되는지 
> 설명하기 위해 사용하는 지표로 보통 비율을 사용한다.

- [x] ch11 - '마치며'







